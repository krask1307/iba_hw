# hw_4
1. С помощью .gitignore, сделать так, чтобы все файлы *.txt не попадали в репозиторий.
2. Изучить что такое git cherry-pick.
3. Продемонстрировать применение git cherry-pick на собственном репозитории (придумать любой пример).
4. Какая разница между git rebase и git merge ?
5. Какая разница между git pull и git fetch ?
6. Что такое git submodule ?
7. Изучить гит стратегии https://bool.dev/blog/detail/git-branching-strategies
---



**1.**
```
# echo "*.txt" > .gitignore
```
```
# date | tee 1.txt 2.txt 3.txt 4.txt 5.txt 6.log
```
```
# git status

On branch main
Your branch is up to date with 'origin/main'.
        new file:   .gitignore
        new file:   6.log
```
```
# git commit -m "add gitignore"

# git push
```
Old:
![Alt text](https://github.com/krask1307/iba_hw/blob/master/hw_4/screenshots/1.png)

New:
![Alt text](https://github.com/krask1307/iba_hw/blob/master/hw_4/screenshots/2.png)

Репа:
https://github.com/krask1307/lesson4



<br>
<br>

**2.**
**git cherry-pick** берёт изменения, вносимые одним коммитом, и пытается повторно применить их в виде нового коммита в текущей ветке. Эта возможность полезна в ситуации, когда нужно забрать парочку коммитов из другой ветки, а не сливать ветку целиком со всеми внесенными в нее изменениями.

<br>
<br>

**3.**
```
# git branch
* main
  vetka2
  vetka3
```
```
# git checkout vetka2
Switched to branch 'vetka2'
```
```
# cat file_vetka2.sh
vetka2
```
```
# echo "text1" >> file_vetka2.sh
# git add .
# git commit -m "text1"
# git push
```
```
# echo "text2" >> file_vetka2.sh
# git add .
# git commit -m "text2"
# git push
```
```
# git log --pretty=oneline
...
26f8240d51f3cbf43a20bc83c2350d2e06904642 text1
...
```
```
# git checkout main
# git cherry-pick 26f8240d51f3cbf43a20bc83c2350d2e06904642
```
```
# cat file_vetka2.sh
vetka2
text1
```
```
# git push
```

<br>
<br>

**4.**
**git rebase VS git merge**

<br>

_**Git Merge**_

Слияние. Независимо от того, созданы ли ветки для тестирования, исправления ошибок или по другим причинам, слияние фиксирует изменения в другом месте. Слияние принимает содержимое ветки источника и объединяет их с целевой веткой. В этом процессе изменяется только целевая ветка. История исходных веток остается неизменной.

![Alt text](https://github.com/krask1307/iba_hw/blob/master/hw_4/screenshots/3.png)

**Плюсы:**
* простота;
* сохраняет полную историю и хронологический порядок;
* поддерживает контекст ветки.

**Минусы:**
* история коммитов может быть заполнена (загрязнена) множеством коммитов;
* отладка с использованием git bisect может стать сложнее.


_**Git Rebase**_

Rebase — еще один способ перенести изменения из одной ветки в другую. Rebase сжимает все изменения в один «патч». Затем он интегрирует патч в целевую ветку.

В отличие от слияния, перемещение перезаписывает историю, потому что она передает завершенную работу из одной ветки в другую. В процессе устраняется нежелательная история.

![Alt text](https://github.com/krask1307/iba_hw/blob/master/hw_4/screenshots/4.png)

**Плюсы:**

* Упрощает потенциально сложную историю
* Упрощение манипуляций с единственным коммитом
* Избежание слияния коммитов в занятых репозиториях и ветках
* Очищает промежуточные коммиты, делая их одним коммитом, что полезно для DevOps команд

**Минусы:**

* Сжатие фич до нескольких коммитов может скрыть контекст
* Перемещение публичных репозиториев может быть опасным при работе в команде
* Появляется больше работы
* Для восстановления с удаленными ветками требуется принудительный пуш. Это приводит к обновлению всех веток, имеющих одно и то же имя, как локально, так и удаленно, и это ужасно.

<br>

Более наглядный скрин:
<br>
![Alt text](https://github.com/krask1307/iba_hw/blob/master/hw_4/screenshots/5.png)

<br>
<br>

**5.**
**git pull VS git fetch**

<br>

При использовании **pull**, git пытается сделать всё за вас. Он сливает любые внесённые коммиты в ветку, в которой вы сейчас работаете. Команда **pull** автоматически сливает коммиты, не давая вам сначала просмотреть их. Если вы не пристально следите за ветками, выполнение этой команды может привести к частым конфликтам.

При использовании **fetch**, git собирает все коммиты из целевой ветки, которых нет в текущей ветке, и сохраняет их в локальном репозитории. Однако он не сливает их в текущую ветку. Это особенно полезно, если вам нужно постоянно обновлять свой репозиторий, но вы работаете над функциональностью, неправильная реализация которой может негативно сказаться на проекте в целом. Чтобы слить коммиты в основную ветвь, нужно использовать **merge**.

Грубо говоря, по дефолту **git pull** — это шоткод для последовательности двух команд: **git fetch** (получение изменений с сервера) и **git merge** (сливание в локальную копию).

<br>
<br>

**5.**
**git submodule**

<br>

Иногда возникает потребность использовать в проекте готовый модуль или библиотеку. Причем это может быть как стороннее решение, так и ваша собственная разработка. Вы можете скопировать код библиотеки в проект, либо подключить его с помощью пакетного менеджера вроде npm, Rubygems или Composer.

Но что если стабильной версии модуля нет, и ему еще требуется отладка и доработка? Система контроля версий Git позволяет подключать один репозиторий, как поддиректорию другого. Эти вложенные репозитории называются подмодулями Git. Такая структура удобна для разработки и тестирования — у вас будет система контроля версий для каждого репозитория, а также вы сможете отлавливать и исправлять ошибки прямо в подмодуле. 

Помимо отладки, подмодули — способ абстрагировать какой-то компонент, чтобы его можно было использовать в нескольких проектах и дорабатывать независимо от основного приложения.
